.386Р 				; (1)Раpрешение команд МП 386 и 486
; Структура для описаниядискриптора сегментов
descr 	struc		; (2)
limit 	dw	0		; (3) Граница (биты 0 ... 15)
base_l	dw	0		; (4) База биты 0 ... 15
base_m	db	0		; (5) База биты 16 ... 23
attr_1 	db	0		; (6) Байт атрибутов 1
attr_2 	db	0		; (7) Граница (биты 16...19) и атрибуты 2
base_h 	db	0		; (8) База, биты 24...31
descr 	ends		; (9)


data	segment		; (10) Начало сегмента данных
; Таблица глобальных дескрипторов GDT
gdt_null	descr 	<0, 0, 0, 0, 0, 0>			; (11) Нулевой дескриптор
gdt_data	descr 	<data_size-1, 0, 0, 92h>	; (12) Селектор 8, сегмент данных
gdt_null	descr 	<code_size-1,,, 98h>		; (13) Селектор 16, сегмент команд
gdt_stack	descr 	<255, 0, 0, 92h>			; (14) Селектор 24б сегмент стека
gdt_screen 	descr 	<4095, 8000h, 0Bh, 92h>		; (15) Селектор 32, видеобуфер
gdt_size = $ - gdt_null							; (16) Размер GDT
; Поля данных программы
pdescr	dq		0								; (17) Псевдодескриптор
sym		db		1								; (18) Символ для вывода на экран
attr 	db 		1Eh								; (19) Его атрибут
mes		db		27, '[31;42m Вернулись в реальный режим!', 27, '[0m$	;(20)
data_size = $ - gdt_null						; (21) Размер сегмента данных
data ends										; (22) Конец сегмента данных


text	segment 'code' use16			; (23) укажем 16-разрядный режим
		assume CS:text, DS:data 		; (24)
main	proc							; (25)
		xor 	EAX, EAX				; (26) Очистим EAX
		mov 	AX, data 				; (27) Загрузим в DS сегментный
		mov	 	DS, AX 					; (28) адрес сегмента данных
; Вычислим 32-битовый линейный адрес сегмента данных и загрузим его
; в дескриптор сегмента данных в GDT.
		shl		EAX, 4					; (29) В EAX линейный базовый адрес
		mov		EBP, EAX 				; (30) Сохраним его в EBP
		mov		BX, offset gdt_data 	; (31) В BX адрес дескриптора
		mov		[BX].basw_l, AX			; (32) Загрузим младшую часть базы
		rol		EAX, 16					; (33) Обмен старшей и младшей половин EAX
		mov		[BX].base_m, AL			; (34) Загрузим среднюю часть базы
; Аналогично для линейного адреса сегмента стека
		xor 	EAX, EAX				; (42)
		mov		AX, SS					; (43)
		shl		EAX, 4					; (44)
		mov		BX,offset gdt_stack		; (45)
		mov		[BX].base_l, AX			; (46)
		rol		EAX, 16					; (47)
		mov		[BX].base_m, AL			; (48)
; Подготовим псевдодескриптор pdescr и загрузим регистр GDTR
		mov		dword ptr pdescr+2, EBP		; (49) База GDT, биты 0...31
		mov		word ptr pdescr, gdt_size-1	; (50) Граница GDT
		lgdt	pdescr						; (51) Загрузим регистр GDTR
; Подготовимся к переходу в защищенный режим
		cli								; (52) Запрет аппаратных прерываний
		mov		AL, 80h 				; (53) Запрет NMI
		out		70h, AL					; (54) Порт КМОП-микросхемы
; Переходим в защищенный режим
		mov		EAX, CR0				; (55) Получчим содержимое CR0
		or		EAX, 1					; (56) Установим бит PE
		mov		CR0, EAX				; (57) Запишем назад в CR0
; Теперь процессор работает в защищенном режиме
; Загружаем в CS:IP селектор:смещение точки continue
; и заодно очищаем очередь команд
		db		0EAh					; (58) Код команды far jmp
		dw 		offset continue			; (59) Смещение
		dw 		16						; (60) Селектор сегмента команд
continue:								; (61)
; Делаем адресуемыми данные
		mov 	AX, 8					; (62) Селектор сегмента данных
		mov		DS, AX					; (63)
; Делаем адресуемым стек
		mov		AX, 24 					; (64) Селектор сегмента стека
		mov		SS, AX					; (65)
; Инициализируем ES и выводим символы
		mov		AX, 32					; (66) Селектор сегмента видеобуфера
		mov		ES, AX 					; (67)
		mov		BX, 800					; (68) Начальное смещение на экране
		mov		CX, 640					; (69) Число выводимых символов
		mov		AX, word ptr sym		; (70) Начальный символ с атрибутом
screen:	mov		ES : [BX], AX			; (71) Вывод в видеобуфере
		add		BX, 2					; (72) Сместимся в видеобуфере
		inc 	AX						; (73) Следующий символ
		loop	screen 					; (74) Цикл вывода на экран
; Подготовим переход в реальный режим
; Сформируем и загрузим дескрипторы для реального режима
		mov 	gdt_data.limit, 0FFFFh	; (75) Граница сегмента данных
		mov		gdt_code.limit, 0FFFFh  ; (76) Граница сегмента команд
		mov		gdt_stack.limit, 0FFFFh	; (77) Граница сегмента стека
		mov		gdt_screen.limit, 0FFFFh; (78) Граница дополнительного сегмента
		mov		AX, 8					; (79) Загрузим теневой регистр
		mov		DS, AX					; (80) сегмента данных
		mov		AX, 24					; (81) Загрузим теневой регистр
		mov		SS, AX					; (82) стека
		mov		AX, 32					; (83) Загрузим теневой регистр
		mov		ES, AX					; (84) дополнительного сегмента
; Выполним дальний переход для того, чтобы заново загрузить
; селектор в регистр CS и модифицировать его теневой регистр
		db		0EAh					; (85) Командой дальнего перехода
		dw 		offset go 				; (86) загрузим теневой регистр
		dw 		16 						; (87) сегмента команд
; Переключим режим процессора
go:		mov		EAX, CR0 				; (88) Получим содержимое CR0
		and 	EAX, 0FFFFFFFEh			; (89) Сбросим бит PE
		mov		CR0, EAX				; (90) Запишем назад в CR0
		db		0EAh					; (91) Код команда far jmp
		dw 		offset return 			; (92) Смещение
		dw 		text 					; (93) Сегмент
; Теперь процессор снова работает в реальном режиме
; Восстановить операционную среду реального режима
return:	mov 	AX, data 				; (94) Восстановим
		mov 	DS, AX					; (95) адресуемость данных
		mov 	AX, stk 				; (96) Восстановим
		mov		SS, AX					; (97) адресуемость стека
; Разрешим аппаратные и немаскируемые прерывания
		sti 							; (98) Разрешение прерываний
		mov		AL, 0					; (99) Сброс бита 7 в порте CMOS -
		out 	70h, AL					; (100) - разрешение NMI
; Проверим выполнение функций DOS после возврата в реальный режим
		mov		AH, 09h					; (101)
		mov 	DX, offset mes 			; (102)
		int 	21h 					; (103)
		mov 	AX, 4C00h 				; (104) Завершим программу
		int 	21h 					; (105) обычным образом
main	endp 							; (106) 
code_size = $ - main 					; (107) Размер сегмента команд
texxt	ends 							; (108)

stk 	segment stack 'stack' 			; (109)
		db		256 dup ('^') 			; (110)
stk 	ends 							; (111)
		end 	main 					; (112)




